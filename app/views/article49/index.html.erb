<h1>Juliaで数値計算</h1>
<br>
<h3>オイラー丸山法</h3>
<br>
<p>オイラー法（またはオイラーの前進差分法）は、常微分方程式の数値的な近似解を求めるための手法の一つです。オイラー丸山法（または改良オイラー法）は、オイラー法の改良版で、数値解の精度を向上させるために微分値をより正確に近似します。

</p><br>
<p>オイラー法（またはオイラーの前進差分法）は、常微分方程式の数値的な近似解を求めるための手法の一つです。オイラー丸山法（または改良オイラー法）は、オイラー法の改良版で、数値解の精度を向上させるために微分値をより正確に近似します。

</p><br>
<ol>
    <li>初期条件の設定: 初期の時刻 t0 と初期の状態 y0 を設定します。

</li>
<li>時間ステップと終了時刻の設定: 時間ステップ h（またはΔt）を設定し、終了時刻 t_end を決めます。また、ステップ数 N は N = (t_end - t0) / h と計算されます。

</li>
<li>ループの開始: t = t0 と y = y0 を初期化します。

</li>
<li>時間ステップごとの計算: N 回のイテレーションを行います。
</li>
<ul>
    <li>a. 現在の時刻 t での微分値 f(t, y) を計算します。
</li>
<li>b. 次の時刻 t + h での近似解 y_next を以下のように計算します。
</li>
<p>y_next = y + h * f(t, y)
</p>
<li>c. t と y を t + h と y_next に更新します。

</li>
</ul>
<li>結果の出力: 数値解 y を表示または保存します。

</li>
</ol>
<p>オイラー丸山法は、微分値の近似によって誤差が生じるため、時間ステップ h を小さくするとより精度の高い結果が得られます。ただし、ステップ数が増えると計算量が増大することにも注意が必要です。

</p>
<p>以下は、Juliaを使用してオイラー丸山法を実装する例です。

</p>
<pre><code class="julia">
function euler_method(f, t0, y0, t_end, h)
    t = t0
    y = y0
    
    while t <= t_end
        # メインの計算
        y_next = y + h * f(t, y)
        
        # 結果の出力
        println("t: ", t, "   y: ", y)
        
        # 時間と状態の更新
        t += h
        y = y_next
    end
end

# サンプルとして使用する微分方程式
f(t, y) = t * y

# 初期条件とパラメータの設定
t0 = 0.0
y0 = 1.0
t_end = 2.0
h = 0.1

# オイラー丸山法の実行
euler_maruyama_method(f, g, t0, y0, t_end, h)


</code></pre>
<p>この例では、微分方程式として `f(t, y) = t * y` を使用しました。初期条件として `t0 = 0.0`、`y0 = 1.0` を設定し、終了時刻 `t_end = 2.0`、時間ステップ `h = 0.1` で計算を行います。

オイラー丸山法では、各ステップでの近似解の値が表示されます。時間 `t` と対応する近似解 `y` が表示されるので、数値的な解の挙動を確認することができます。

なお、オイラー丸山法は高次の数値積分法に比べて精度が低い場合があります。より高度な数値積分法を使用する場合は、Runge-Kutta法やアダムス法などを検討することもおすすめです。</p>
<br>
<h3>ミルスタイン法</h3>
<br>
<p>ミルスタイン法（Milstein method）は、確率微分方程式（Stochastic Differential Equation, SDE）の数値解法の一つです。オイラー丸山法の改良版であり、数値解の精度を向上させるために確率項の近似に二次の項を追加します。

</p>
<p>ミルスタイン法は以下の手順で実行されます。

</p>
<ol>
    <li>初期条件の設定: 初期の時刻 t0 と初期の状態 y0 を設定します。

</li>
<li>時間ステップと終了時刻の設定: 時間ステップ h（またはΔt）を設定し、終了時刻 t_end を決めます。また、ステップ数 N は N = (t_end - t0) / h と計算されます。

</li>
<li>ループの開始: t = t0 と y = y0 を初期化します。

</li>
<li>時間ステップごとの計算: N 回のイテレーションを行います。
</li>
<ul>
    <li>a. 現在の時刻 t での微分値 f(t, y) を計算します。
</li>
<li>b. 現在の時刻 t での確率項の微分値 g(t, y) を計算します。
</li>
<li>c. 次の時刻 t + h での近似解 y_next を以下のように計算します。
</li>
<p>y_next = y + h * f(t, y) + g(t, y) * sqrt(h) * randn() + 0.5 * g(t, y) * g_prime(t, y) * (randn()^2 - 1) * h ここで、g_prime(t, y) は g(t, y) を y に関して偏微分したものです。
</p>
<li>d. t と y を t + h と y_next に更新します。

</li>
</ul>
<li>結果の出力: 数値解 y を表示または保存します。

</li>


</ol>
<p>ミルスタイン法はオイラー丸山法に比べて精度が向上しており、より高次の項を考慮した確率項の近似を行います。そのため、数値解の精度が向上し、特に確率項の非線形性が強い場合に有効です。

</p>
<p>Juliaでミルスタイン法を実装するには、上記の手順に基づいてコードを記述することができます。具体的な微分方程式やパラメータに応じて関数 f(t, y)、g(t, y)、g_prime(t, y) を定義します。
</p>
<pre><code class="julia">
function milstein_method(f, g, g_prime, t0, y0, t_end, h)
    t = t0
    y = y0
    
    while t <= t_end
        # メインの計算
        f_val = f(t, y)
        g_val = g(t, y)
        g_prime_val = g_prime(t, y)
        
        y_next = y + h * f_val + g_val * sqrt(h) * randn() + 0.5 * g_val * g_prime_val * (randn()^2 - 1) * h
        
        # 結果の出力
        println("t: ", t, "   y: ", y)
        
        # 時間と状態の更新
        t += h
        y = y_next
    end
end

# サンプルとして使用するSDEの微分方程式
f(t, y) = -0.5 * y
g(t, y) = 1.0
g_prime(t, y) = 1.0

# 初期条件とパラメータの設定
t0 = 0.0
y0 = 1.0
t_end = 2.0
h = 0.1

# ミルスタイン法の実行
milstein_method(f, g, g_prime, t0, y0, t_end, h)

</code></pre>
<p>上記のコードでは、確率微分方程式（Stochastic Differential Equation, SDE）の数値解を求めるためにミルスタイン法を使用しています。微分方程式は f(t, y) = -0.5 * y、確率項は g(t, y) = 1.0、g_prime(t, y) = 1.0 として設定されています。

</p>
<p>ミルスタイン法では、オイラー丸山法と同様に通常の微分項 h * f(t, y) に加えて確率項 g(t, y) * sqrt(h) * randn() を追加します。さらに、改良のために二次の項 0.5 * g(t, y) * g_prime(t, y) * (randn()^2 - 1) * h も追加されています。

</p>
<p>結果として得られる数値解は、確率的な要素を考慮してランダムな変動を含んでいます。各ステップでの時間 t と対応する近似解 y が表示されます。

</p>
<p>ミルスタイン法は、確率項の非線形性による影響をより正確に捉えることができます。しかし、依然として厳密な解の近似ではなく、数値解の精度は他の高度な確率的数値積分法に比べて低い場合があります。問題に応じて適切な処理が必要です。</p>
<br>
<h3>後退オイラー法</h3>
<br>
<p>後退オイラー法（Backward Euler method）は、常微分方程式の数値解法の一つであり、微分方程式を近似するために差分近似を行います。後退オイラー法は、次のステップでの解を求める際に未知の値を含む方程式を解くことによって数値解を得ます。

</p>
<p>後退オイラー法の手順は以下の通りです。

</p>
<ol>
    <li>初期条件の設定: 初期の時刻 t0 と初期の状態 y0 を設定します。

</li>
<li>時間ステップと終了時刻の設定: 時間ステップ h（またはΔt）を設定し、終了時刻 t_end を決めます。また、ステップ数 N は N = (t_end - t0) / h と計算されます。

</li>
<li>ループの開始: t = t0 と y = y0 を初期化します。

</li>
<li>時間ステップごとの計算: N 回のイテレーションを行います。
</li>
<ul>
    <li>a. 未知の値を含む方程式を解くために、次の時刻 t + h での近似解 y_next を求めます。具体的には、方程式 y_next = y + h * f(t + h, y_next) を解くことになります。これは、次のステップでの解を求める際に未知の値 y_next が現れることを意味します。
</li>
<li>b. y_next を求めるために、非線形方程式の解を数値的に求めるための反復法（ニュートン法など）を適用することがあります。
</li>
<li>c. t と y を t + h と y_next に更新します。

</li>
</ul>
<li>結果の出力: 数値解 y を表示または保存します。

</li>
</ol>
<p>後退オイラー法は数値解の安定性が高く、特に非線形な微分方程式に対して適しています。ただし、反復法を使用して非線形方程式を解く必要があるため、計算コストが高くなる場合があります。

</p>
<p>Juliaで後退オイラー法を実装するには、上記の手順に基づいてコードを記述することができます。具体的な微分方程式に応じて関数 f(t, y) を定義し、適切な反復法を使用して未知の値 y_next を求める必要があります。




</p>
<br>

